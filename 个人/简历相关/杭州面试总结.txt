1.Spring bean 的生命周期
2.多线程
3.数据库的隔离级别
4.spring 控制反转和面向切面
5.linux基本命令，
6.设计模式
7.vue特性
8.Elasticsearch 搜索引擎
9.消息中间件mq
10.redis配置,redis集群.
11.map底层
12.http协议,http于https的区别
http头
1. Accept：告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。

2. Accept-Charset： 浏览器申明自己接收的字符集
Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法 （gzip，deflate）
Accept-Language：：浏览器申明自己接收的语言语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。

3. Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。

4. Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。

5. Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，该头部来回应自己的身份验证信息给WEB服务器。

6. Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）
max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）
max-stale：（可以接受过去的对象，但是过期时间必须小于 
max-stale 值）
min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的
缓存对象）
响应：public(可以用 Cached 内容回应任何用户)
private（只能用缓存内容回应先前请求该内容的那个用户）
no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）
max-age：（本响应包含的对象的过期时间）
ALL:  no-store（不允许缓存）

7. Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应
后，断开连接，不要等待本次连接的后续请求了）。
keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的
响应后，保持连接，等待本次连接的后续请求）。
响应：close（连接已经关闭）。
keepalive（连接保持着，在等待本次连接的后续请求）。
Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持
连接多长时间（秒）。
例如：Keep-Alive：300

8. Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。
例如：Content-Encoding：gzip                   
Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。
Content-Length：    WEB 服务器告诉浏览器自己响应的对象的长度。
例如：Content-Length: 26012
Content-Range：    WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。
例如：Content-Range: bytes 21010-47021/47022
Content-Type：      WEB 服务器告诉浏览器自己响应的对象的类型。
例如：Content-Type：application/xml

9. ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，
如果被修改了，其 Etag 也会别修改， 所以，ETag 的作用跟 Last-Modified 的
作用差不多，主要供 WEB 服务器 判断一个对象是否改变了。
比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，
浏览器就会把先前获得的 ETag 值发送给  WEB 服务器，然后 WEB 服务器
会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件
有没有改变了。

10. Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在
跟WEB服务器验证了其有效性后，才能用来响应客户请求。
是 HTTP/1.0 的头部。
例如：Expires：Sat, 23 May 2009 10:02:12 GMT

11. Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。
例如：Host：rss.sina.com.cn

12. If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。
If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。

13. If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求
的动作（比如返回对象），否则返回代码304，告诉浏览器该对象
没有修改。
例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT
If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行
请求的动作（比如返回对象）。

14. If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分
给我，如果对象改变了，就把整个对象给我。 浏览器通过发送请求对象的 
ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否
改变了。
总是跟 Range 头部一起使用。

15. Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，
动态页面的最后产生时间等等。
例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT

16. Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，
到该头部指定的位置去取。
例如：Location：

http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif

17. Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。
例如：Pragma：no-cache

18. Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。
Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。

19. Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。
例如：Range: bytes=1173546-

20. Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。
例如：Referer：http://www.sina.com/

21. Server: WEB 服务器表明自己是什么软件及版本等信息。
例如：Server：Apache/2.0.61 (Unix)

22. User-Agent: 浏览器表明自己的身份（是哪种浏览器）。
例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;   
rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14

23. Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）
作了怎样的编码，比如是否分块（chunked）。
例如：Transfer-Encoding: chunked

24. Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应
所返回的对象响应后续的请求。
假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：
Content-Encoding: gzip; Vary: Content-Encoding  那么 Cache 服务器会分析后续
请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值
一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己
Cache 里面压缩后的实体响应给不具备解压能力的浏览器。
例如：Vary：Accept-Encoding

25. Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用
什么协议（和版本）发送的请求。
当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面
添加 Via 头部，并填上自己的相关信息，当下一个代理服务器 收到第一个代理
服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via 
头部，并把自己的相关信息加到后面， 以此类推，当 OCS 收到最后一个代理服
务器的请求时，检查 Via 头部，就知道该请求所经过的路由。
例如：Via：1.0 236-81.D07071953.sina.com.cn:80 (squid/2.6.STABLE13)

vue的特性
（1） 简洁 （2） 轻量 （3）快速 （4） 数据驱动 （5） 模块友好 （6） 组件化

NIO和传统IO最大的区别是什么？分别适用什么样的场景？
NIO采用同步非阻塞的IO编程模型
传统IO采用同步阻塞式的IO编程模型

简述JVM的内存模型
主要可以分为堆、栈、方法区，堆又分为新生代、survival、老年代；

JVM的内存溢出的原因有哪些？如果发生内存溢出，可以通过什么方式来分析？
堆内存溢出：创建的对象太多，垃圾回收不及时
栈内存溢出：线程数量太多，或者方法的压栈深度太大
方法区溢出：加载的类太多
内存溢出可以使用memoryananlyzer工具来分析JVM溢出dump文件

JVM的垃圾回收算法有哪些？ CMS垃圾回收器会发生stop the world现象吗？
标记清除
标记整理
复制算法

RPC框架有哪些？
HADOOP RPC
dubbo
mina

1.框架底层实现原理
2.分布式,集群原理
3.多个dao被一个mapper映射
    分布式: 
    1.将不同功能数据放到不能的机器上。 
    2.将同一数据放到不同的服务器上(数据副本)，服务器之间通过网络互通。（涉及到数据的一致局性问题）。 
    集群： 
    就是用多个服务器来处理同一个功能或存储数据（这个有点像分布式(数据备份)）,来提高对多用户请求的处理,防止一个服务器处理不过来。一般会通过反向代理(分发请求)来实现集群的功能（nginx：一个反向代理的软件）。
    nginx:反向代理软件 
    用户的请求都先到达nginx,nginx再跟据配置计算出把这个请求发到集群里的那个服务器进行处理，nginx再接收它处理完的结果，再把结果返回给用户 
4.支付的功能，怎么去实现
    答：种是调用各个银行提供的接口，另一种是使用第三方集成好的支付功能。两种方式各有优劣，这个相信行内人士都是非常了解的了。对于第三方支付来说会需要提交企业5证来验证，还会有部分手续费，但是实现起来就非常方便了。对于直接使用银联接口的话就是使用起来必来麻烦，要为各个银行写接口实现，但是相比起来就更加安全了。
5.垃圾回收机制,java多线程
6.什么是RPC？简述其底层的实现机制
RPC：远程过程调用，简单来说，就是进程间的调用
底层的实现：网络通信+序列化+反射+动态代理


1.自我介绍
围绕着工作经验,公司项目介绍.然后就是自己掌握的技术有哪些,
2.职业规划。
架构师发展方向
3.问公司什么问题
公司多少人项目,采用什么框架,
4.自身的优,缺点
我一直努力提高自己对事情优先级的管理。我很喜欢新的挑战，和新的伙伴一起工作，这经常让我同时面临许多不同的事情，我曾一度有些手忙脚乱。近来，我一直在锻炼自己的项目管理和同时处理多个事情的能力。如今，当接到新任务时，我有信心能够按时保质保量完成。
5.与人争吵,怎么办
5.工作中遇到的最大难题
6.离职原因




51 boss 拉钩  领英 前程无忧 智联 

1.学会了mysql的存储过程,查询优化 编写mysql
2.系统的导入,导出 导入包括 批量导入,增值导入.错误提示,中英文对照翻译
3.统计视图开发,高级查询
4.运用缓存,改造所有的下拉菜单,提示是否删除,中英文
5.权限判断
6.大项目金额,功能开发
7.mysql管理员
8.svn管理员
9.双语系统
10.自动调用远程服务,按照算法,随机更新demo数据
11.debug调式系统,调式谷歌
12.爬虫,抓取数据
13.国际化时间  
    js中
    var exp = new Date();
    var gmtHours = -(exp.getTimezoneOffset()/60);
    获取UTC标准时间差。然后在java代码中。将时间进行转换 
14. 动态设置,月,季度,年度  

熟悉tcp/ip、http、https等网络协议，熟悉常用高并发网络模型及相关设计及实现方式；
有良好的编码习惯，以及技术文档的编写能力；
掌握分布式原理，熟悉当前流行的分布式框架，需要有相关项目实战经验；有高并发&负载均衡处理经验者
熟悉Linux操作系统，掌握常用的Linux命令；
熟练掌握Apache，Tomcat，MemCached¸ JBoss，Solr，Cassandra, Spark 等应用服务器配置和应用部署；
熟悉WebService/REST/SOAP协议,熟悉相关中间件技术；
熟练掌握MySQL，redis，mongodb等数据库，有数据库优化经验；熟悉Kafka/ActiveMQ/RocketMQ等其中一种消息队列
熟悉Socket编程、设计模式、TCP/IP协议及从事过tcp相关开发； 
了解消息队列的应用场景、调优
掌握多线程、异步、注解等多种开发手段,理解分布式事务, 熟悉缓存、中间件等开源系统使用
hadoop离线分析、Storm实时计算、spark内存计算的学习,Hive,Hbase。
了解Elasticsearch 搜索引擎的使用